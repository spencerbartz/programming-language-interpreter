describe('Interpreter', function () {
    let interpreter;

    beforeEach(function () {
        interpreter = new Interpreter();
    });

    it('should return the current state', function () {
        let state = interpreter.getState();
        Object.keys(state).forEach(k => {
            if (k === 'cells') {
                expect(state[k].length).toEqual(30000);
            } else if (k === 'stack') {
                expect(state[k].length).toEqual(0);
            } else {
                expect(state[k]).toBeFalsy();
            }
        });
      });

      it('should parse a hello world program without error', function () {
        let src = '++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.';
        interpreter.parse(src);
        expect(interpreter.getState().outputBuffer).toEqual("Hello World!\n");
      });

      it('should find matching brace positions', function () {
        let src ='[+-+-+-+-]';
        expect(interpreter.findMatchingBracePos(src)).toEqual(9);
      });

      it('should convert text to source code', function () {
        let text = 'hello';
        let src = interpreter.asciiToSrc(text);
        expect(src).toEqual('[-]>[-]<\n+++++++++++++[>++++++++<-]>.<\n+++[>-<-]>.<\n+++++++[>+<-]>.<\n>.<\n+++[>+<-]>.<\n');
      });

      it('should be able to run the code generated by asciiToSrc', function () {
        let text = 'Runnin on Ascii';
        let src = interpreter.asciiToSrc(text);
        interpreter.parse(src);
        expect(interpreter.getState().outputBuffer).toEqual('Runnin on Ascii');
      });

      it('should throw an error on unmatched brace', function () {
        expect(() => interpreter.findMatchingBracePos('', '[')).toThrow(new Error('Unmatched brace'));
      });

});